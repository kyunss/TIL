## 클래스 및 인터페이스

#### 클래스와 인터페이스의 선언 및 인스턴스 생성

#### 프로퍼티

#### 접근 제한자

#### 생성자

#### 함수

#### 상속 및 인터페이스 구현

#### this

#### 정적 필드 및 메서드

자바에서는 static필드를 사용해서 클래스 내에 상수나 인스턴스 생성 없이 사용가능한 메서드를 만들지만, 코틀린에서는 static을 지원하지 않는다. 일반적인 경우, 클래스 안에 선언한 static 변수와 메서드는 패키지 단위로 선언할 수 있다. 코드를 보자.

```java
//Foo.java
package foo.bar;

public class Foo {
  public static final int FOO = 123;
  public static void foo() {}
  public void bar() {}
}

//----다른 파일
import foo.bar.Foo;
public class Bar {
  public void bar(){
    //FOO클래스 내의 정적 필드 FOO값을 참조한다.
    int foo = Foo.FOO;
    //FOO클래스 내의 정적 메소드 foo를 호출한다.
    Foo.foo();
  }
}
```

```kotlin
//Foo.kt
package foo.bar

//값 FOO를 패키지 foo.bar에 선언한다.
const val FOO = 123
//함수 foo를 패키지 foo.bar에 선언한다.
fun foo() {}

class Foo {
  //함수 bar()는 Foo의 인스턴스를 생성해야 사용할 수 있다.
  fun bar() {}
}


//----다른 파일
import foo.bar.FOO
import foo.bar.foo

class Bar {
  fun bar() {
    //foo.bar패키지 내의 값과 함수를 참조할 수 있다.
    val foo = FOO;
    foo();
  }
}
```

이렇게 패키지 단위로 선언한 변수나 메서드는 클래스가 아닌 패키지에 종속되므로 import문에서도 {패키지 이름}.{값 혹은 함수 이름} 을 사용한다.  

패키지 단위 함수는 특정 클래스에 종속되어 있지 않으므로 클래스 내 private으로 선언된 멤버에 접근해야 하는 팩토리 메서드는 패키지 단위 함수로 구현 할 수 없다. 이런 경우 클래스 당 하나씩 인스턴스 생성 없이 사용할 수 있는 object를 정의할 수 있는데,**동반객체(companion object)** 를 사용하면 클래스 내 모든 멤버에 접근할 수 있으면서 인스턴스 생성 없이 호출할 수 있는 함수를 작성할 수 있다. 

```kotlin
//생성자의 접근 제한자가 private으로 외부에선 접근할 수 없다.
class User private constructor(val name: String , val regiterTime: Long) {
  
  companion object {
    //companion object는 클래스 내부에 존재하므로, private으로 선언된 생성자에 접근할 수 있다.
    fun create(name: String) : User {
      return User(name, System.currentTimeMilles())
    }
  }
}
```

이렇게 만들어 놓으면 `User.create("ukhyun Kwak")` 이렇게 쓸 수 있당.

#### 싱글톤

#### enum 클래스

#### 어노테이션 클래스

#### 중첩 클래스



