## 변환 연산자

#### map

- map() 함수를 통해서 입력값을 변환한다. Map함수의 원형을 알아보자

```Java
@CheckReturnValue
@SchedulerSupport(value="none")
public final <R> Observable<R> map(Function<? super T, ? extends R> mapper)
```

@schedulerSupport가 none이므로 스케쥴러를 지원하지 않는다. 현재 쓰레드에서 실행됨. RxJava에서 사용하는 세 가지 제네릭 함수형 인터페이스를 알아보자.

	- Predicate<T> : t값을 받아서 참/거짓을 반환한다.
	- consumner<T> : t값을 받아서 처리한다. 반환값은 없다.
	- Function<T,R> : t값을 받아서 결과값 R을 반환한다.

#### flatMap

- flatMap()은 map()과 유사하지만 Observable의 데이터를 Observables로 반환하여 단일 Observable로 배출할 수 있다. 원형을 살펴보자

```java
@SchedulerSupport(SchedulerSupport.NONE)
public final <R> Observable<R> flatMap(
Function <? super T, ? extends ObservableSource<? extends R>> mapper
)
```

함수를 살펴보면 T를 넣으면 여러개의 R(Observable 형태)가 나온다는 뜻이다. flatMap()을 이용하여 구구단을 출력하는 Observable만들어본다면

- 먼저 자바의 for문을 Observable로 변환하고 -> 사용자 함수를 정의하면 된다. 먼저 자바의 for문을 Observable로 변환을 해보면

```Java
int dan = Integer.parseInt(int.nextLine()); //입력받은 1~9 사이의 숫자

//for문을 Observable의 range로 대체한다.
//range(start,count)함수는 start부터 count 개수만큼 숫자값을 발행한다.
Observable<Integer> source = Observable.range(1,9); 
source.subscribe(row -> System.out.println(dan * row))
```

- 여기서 dan에 대한 예외 처리가 안되어있다. dan값에 문제가 없는지도 Observable안에서 확인하는것이 좋다. dan을 받아서 9개의 String을 출력해야 하므로, 1개의 결과만 만들어내는 map()이 아니라 flatMap()을 써야 한다.  한개의 값을 받아서 Observable을 출력하는 제네릭 함수형 인터페이스 Funtion<T,R> 을 정의해보자.

```java
int dan = Integer.parseInt(int.nextLine());

//num은 제네릭 함수의 변수이다.
Function<Integer, Observable<String>> gugudan = num -> 
  Observable.range(1,9).map(row -> num + "*" + row + " = " + dan * row);

//함수에 함수를 넣었다. dan을 발행하여 여러개의 데이터를 포함하는 Observable로 받아야 하므로 flatMap()을 쓴것.
Observable<String> source = Observable.just(dan).flatMap(gugudan);
source.subscribe(System.out::println);
```

- 위에 작성한 구구단 예제를 인라인으로 flatMap() 함수에 넣어보자

```java
Observable<String> source = Observable.just(dan)
  .flatMap(
	num -> Observable.range(1,9)
  .map(row -> num + "*" + row + " = " + num * row) 
);
```

#### concatMap

#### switchMap

#### reduce

#### groupBy

